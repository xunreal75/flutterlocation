// Autogenerated from Pigeon (v10.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "messages.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface PigeonLocationData ()
+ (PigeonLocationData *)fromList:(NSArray *)list;
+ (nullable PigeonLocationData *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonNotificationSettings ()
+ (PigeonNotificationSettings *)fromList:(NSArray *)list;
+ (nullable PigeonNotificationSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PigeonLocationSettings ()
+ (PigeonLocationSettings *)fromList:(NSArray *)list;
+ (nullable PigeonLocationSettings *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation PigeonLocationData
+ (instancetype)makeWithLatitude:(nullable NSNumber *)latitude
    longitude:(nullable NSNumber *)longitude
    accuracy:(nullable NSNumber *)accuracy
    altitude:(nullable NSNumber *)altitude
    bearing:(nullable NSNumber *)bearing
    bearingAccuracyDegrees:(nullable NSNumber *)bearingAccuracyDegrees
    elaspedRealTimeNanos:(nullable NSNumber *)elaspedRealTimeNanos
    elaspedRealTimeUncertaintyNanos:(nullable NSNumber *)elaspedRealTimeUncertaintyNanos
    satellites:(nullable NSNumber *)satellites
    speed:(nullable NSNumber *)speed
    speedAccuracy:(nullable NSNumber *)speedAccuracy
    time:(nullable NSNumber *)time
    verticalAccuracy:(nullable NSNumber *)verticalAccuracy
    isMock:(nullable NSNumber *)isMock {
  PigeonLocationData* pigeonResult = [[PigeonLocationData alloc] init];
  pigeonResult.latitude = latitude;
  pigeonResult.longitude = longitude;
  pigeonResult.accuracy = accuracy;
  pigeonResult.altitude = altitude;
  pigeonResult.bearing = bearing;
  pigeonResult.bearingAccuracyDegrees = bearingAccuracyDegrees;
  pigeonResult.elaspedRealTimeNanos = elaspedRealTimeNanos;
  pigeonResult.elaspedRealTimeUncertaintyNanos = elaspedRealTimeUncertaintyNanos;
  pigeonResult.satellites = satellites;
  pigeonResult.speed = speed;
  pigeonResult.speedAccuracy = speedAccuracy;
  pigeonResult.time = time;
  pigeonResult.verticalAccuracy = verticalAccuracy;
  pigeonResult.isMock = isMock;
  return pigeonResult;
}
+ (PigeonLocationData *)fromList:(NSArray *)list {
  PigeonLocationData *pigeonResult = [[PigeonLocationData alloc] init];
  pigeonResult.latitude = GetNullableObjectAtIndex(list, 0);
  pigeonResult.longitude = GetNullableObjectAtIndex(list, 1);
  pigeonResult.accuracy = GetNullableObjectAtIndex(list, 2);
  pigeonResult.altitude = GetNullableObjectAtIndex(list, 3);
  pigeonResult.bearing = GetNullableObjectAtIndex(list, 4);
  pigeonResult.bearingAccuracyDegrees = GetNullableObjectAtIndex(list, 5);
  pigeonResult.elaspedRealTimeNanos = GetNullableObjectAtIndex(list, 6);
  pigeonResult.elaspedRealTimeUncertaintyNanos = GetNullableObjectAtIndex(list, 7);
  pigeonResult.satellites = GetNullableObjectAtIndex(list, 8);
  pigeonResult.speed = GetNullableObjectAtIndex(list, 9);
  pigeonResult.speedAccuracy = GetNullableObjectAtIndex(list, 10);
  pigeonResult.time = GetNullableObjectAtIndex(list, 11);
  pigeonResult.verticalAccuracy = GetNullableObjectAtIndex(list, 12);
  pigeonResult.isMock = GetNullableObjectAtIndex(list, 13);
  return pigeonResult;
}
+ (nullable PigeonLocationData *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonLocationData fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.latitude ?: [NSNull null]),
    (self.longitude ?: [NSNull null]),
    (self.accuracy ?: [NSNull null]),
    (self.altitude ?: [NSNull null]),
    (self.bearing ?: [NSNull null]),
    (self.bearingAccuracyDegrees ?: [NSNull null]),
    (self.elaspedRealTimeNanos ?: [NSNull null]),
    (self.elaspedRealTimeUncertaintyNanos ?: [NSNull null]),
    (self.satellites ?: [NSNull null]),
    (self.speed ?: [NSNull null]),
    (self.speedAccuracy ?: [NSNull null]),
    (self.time ?: [NSNull null]),
    (self.verticalAccuracy ?: [NSNull null]),
    (self.isMock ?: [NSNull null]),
  ];
}
@end

@implementation PigeonNotificationSettings
+ (instancetype)makeWithChannelName:(nullable NSString *)channelName
    title:(nullable NSString *)title
    iconName:(nullable NSString *)iconName
    subtitle:(nullable NSString *)subtitle
    description:(nullable NSString *)description
    color:(nullable NSString *)color
    onTapBringToFront:(nullable NSNumber *)onTapBringToFront {
  PigeonNotificationSettings* pigeonResult = [[PigeonNotificationSettings alloc] init];
  pigeonResult.channelName = channelName;
  pigeonResult.title = title;
  pigeonResult.iconName = iconName;
  pigeonResult.subtitle = subtitle;
  pigeonResult.description = description;
  pigeonResult.color = color;
  pigeonResult.onTapBringToFront = onTapBringToFront;
  return pigeonResult;
}
+ (PigeonNotificationSettings *)fromList:(NSArray *)list {
  PigeonNotificationSettings *pigeonResult = [[PigeonNotificationSettings alloc] init];
  pigeonResult.channelName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.title = GetNullableObjectAtIndex(list, 1);
  pigeonResult.iconName = GetNullableObjectAtIndex(list, 2);
  pigeonResult.subtitle = GetNullableObjectAtIndex(list, 3);
  pigeonResult.description = GetNullableObjectAtIndex(list, 4);
  pigeonResult.color = GetNullableObjectAtIndex(list, 5);
  pigeonResult.onTapBringToFront = GetNullableObjectAtIndex(list, 6);
  return pigeonResult;
}
+ (nullable PigeonNotificationSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonNotificationSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.channelName ?: [NSNull null]),
    (self.title ?: [NSNull null]),
    (self.iconName ?: [NSNull null]),
    (self.subtitle ?: [NSNull null]),
    (self.description ?: [NSNull null]),
    (self.color ?: [NSNull null]),
    (self.onTapBringToFront ?: [NSNull null]),
  ];
}
@end

@implementation PigeonLocationSettings
+ (instancetype)makeWithAskForPermission:(NSNumber *)askForPermission
    rationaleMessageForPermissionRequest:(NSString *)rationaleMessageForPermissionRequest
    rationaleMessageForGPSRequest:(NSString *)rationaleMessageForGPSRequest
    useGooglePlayServices:(NSNumber *)useGooglePlayServices
    askForGooglePlayServices:(NSNumber *)askForGooglePlayServices
    askForGPS:(NSNumber *)askForGPS
    fallbackToGPS:(NSNumber *)fallbackToGPS
    ignoreLastKnownPosition:(NSNumber *)ignoreLastKnownPosition
    expirationDuration:(nullable NSNumber *)expirationDuration
    expirationTime:(nullable NSNumber *)expirationTime
    fastestInterval:(NSNumber *)fastestInterval
    interval:(NSNumber *)interval
    maxWaitTime:(nullable NSNumber *)maxWaitTime
    numUpdates:(nullable NSNumber *)numUpdates
    accuracy:(PigeonLocationAccuracy)accuracy
    smallestDisplacement:(NSNumber *)smallestDisplacement
    waitForAccurateLocation:(NSNumber *)waitForAccurateLocation
    acceptableAccuracy:(nullable NSNumber *)acceptableAccuracy {
  PigeonLocationSettings* pigeonResult = [[PigeonLocationSettings alloc] init];
  pigeonResult.askForPermission = askForPermission;
  pigeonResult.rationaleMessageForPermissionRequest = rationaleMessageForPermissionRequest;
  pigeonResult.rationaleMessageForGPSRequest = rationaleMessageForGPSRequest;
  pigeonResult.useGooglePlayServices = useGooglePlayServices;
  pigeonResult.askForGooglePlayServices = askForGooglePlayServices;
  pigeonResult.askForGPS = askForGPS;
  pigeonResult.fallbackToGPS = fallbackToGPS;
  pigeonResult.ignoreLastKnownPosition = ignoreLastKnownPosition;
  pigeonResult.expirationDuration = expirationDuration;
  pigeonResult.expirationTime = expirationTime;
  pigeonResult.fastestInterval = fastestInterval;
  pigeonResult.interval = interval;
  pigeonResult.maxWaitTime = maxWaitTime;
  pigeonResult.numUpdates = numUpdates;
  pigeonResult.accuracy = accuracy;
  pigeonResult.smallestDisplacement = smallestDisplacement;
  pigeonResult.waitForAccurateLocation = waitForAccurateLocation;
  pigeonResult.acceptableAccuracy = acceptableAccuracy;
  return pigeonResult;
}
+ (PigeonLocationSettings *)fromList:(NSArray *)list {
  PigeonLocationSettings *pigeonResult = [[PigeonLocationSettings alloc] init];
  pigeonResult.askForPermission = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.askForPermission != nil, @"");
  pigeonResult.rationaleMessageForPermissionRequest = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.rationaleMessageForPermissionRequest != nil, @"");
  pigeonResult.rationaleMessageForGPSRequest = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.rationaleMessageForGPSRequest != nil, @"");
  pigeonResult.useGooglePlayServices = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.useGooglePlayServices != nil, @"");
  pigeonResult.askForGooglePlayServices = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.askForGooglePlayServices != nil, @"");
  pigeonResult.askForGPS = GetNullableObjectAtIndex(list, 5);
  NSAssert(pigeonResult.askForGPS != nil, @"");
  pigeonResult.fallbackToGPS = GetNullableObjectAtIndex(list, 6);
  NSAssert(pigeonResult.fallbackToGPS != nil, @"");
  pigeonResult.ignoreLastKnownPosition = GetNullableObjectAtIndex(list, 7);
  NSAssert(pigeonResult.ignoreLastKnownPosition != nil, @"");
  pigeonResult.expirationDuration = GetNullableObjectAtIndex(list, 8);
  pigeonResult.expirationTime = GetNullableObjectAtIndex(list, 9);
  pigeonResult.fastestInterval = GetNullableObjectAtIndex(list, 10);
  NSAssert(pigeonResult.fastestInterval != nil, @"");
  pigeonResult.interval = GetNullableObjectAtIndex(list, 11);
  NSAssert(pigeonResult.interval != nil, @"");
  pigeonResult.maxWaitTime = GetNullableObjectAtIndex(list, 12);
  pigeonResult.numUpdates = GetNullableObjectAtIndex(list, 13);
  pigeonResult.accuracy = [GetNullableObjectAtIndex(list, 14) integerValue];
  pigeonResult.smallestDisplacement = GetNullableObjectAtIndex(list, 15);
  NSAssert(pigeonResult.smallestDisplacement != nil, @"");
  pigeonResult.waitForAccurateLocation = GetNullableObjectAtIndex(list, 16);
  NSAssert(pigeonResult.waitForAccurateLocation != nil, @"");
  pigeonResult.acceptableAccuracy = GetNullableObjectAtIndex(list, 17);
  return pigeonResult;
}
+ (nullable PigeonLocationSettings *)nullableFromList:(NSArray *)list {
  return (list) ? [PigeonLocationSettings fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.askForPermission ?: [NSNull null]),
    (self.rationaleMessageForPermissionRequest ?: [NSNull null]),
    (self.rationaleMessageForGPSRequest ?: [NSNull null]),
    (self.useGooglePlayServices ?: [NSNull null]),
    (self.askForGooglePlayServices ?: [NSNull null]),
    (self.askForGPS ?: [NSNull null]),
    (self.fallbackToGPS ?: [NSNull null]),
    (self.ignoreLastKnownPosition ?: [NSNull null]),
    (self.expirationDuration ?: [NSNull null]),
    (self.expirationTime ?: [NSNull null]),
    (self.fastestInterval ?: [NSNull null]),
    (self.interval ?: [NSNull null]),
    (self.maxWaitTime ?: [NSNull null]),
    (self.numUpdates ?: [NSNull null]),
    @(self.accuracy),
    (self.smallestDisplacement ?: [NSNull null]),
    (self.waitForAccurateLocation ?: [NSNull null]),
    (self.acceptableAccuracy ?: [NSNull null]),
  ];
}
@end

@interface LocationHostApiCodecReader : FlutterStandardReader
@end
@implementation LocationHostApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [PigeonLocationData fromList:[self readValue]];
    case 129: 
      return [PigeonLocationSettings fromList:[self readValue]];
    case 130: 
      return [PigeonLocationSettings fromList:[self readValue]];
    case 131: 
      return [PigeonNotificationSettings fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface LocationHostApiCodecWriter : FlutterStandardWriter
@end
@implementation LocationHostApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PigeonLocationData class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonLocationSettings class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonLocationSettings class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PigeonNotificationSettings class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface LocationHostApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation LocationHostApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[LocationHostApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[LocationHostApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *LocationHostApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    LocationHostApiCodecReaderWriter *readerWriter = [[LocationHostApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void LocationHostApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<LocationHostApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.getLocation"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getLocationSettings:completion:)], @"LocationHostApi api (%@) doesn't respond to @selector(getLocationSettings:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PigeonLocationSettings *arg_settings = GetNullableObjectAtIndex(args, 0);
        [api getLocationSettings:arg_settings completion:^(PigeonLocationData *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.setLocationSettings"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLocationSettingsSettings:error:)], @"LocationHostApi api (%@) doesn't respond to @selector(setLocationSettingsSettings:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PigeonLocationSettings *arg_settings = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api setLocationSettingsSettings:arg_settings error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.getPermissionStatus"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPermissionStatusWithError:)], @"LocationHostApi api (%@) doesn't respond to @selector(getPermissionStatusWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getPermissionStatusWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.requestPermission"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestPermissionWithCompletion:)], @"LocationHostApi api (%@) doesn't respond to @selector(requestPermissionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestPermissionWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.isGPSEnabled"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isGPSEnabledWithError:)], @"LocationHostApi api (%@) doesn't respond to @selector(isGPSEnabledWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isGPSEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.isNetworkEnabled"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isNetworkEnabledWithError:)], @"LocationHostApi api (%@) doesn't respond to @selector(isNetworkEnabledWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isNetworkEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.changeNotificationSettings"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(changeNotificationSettingsSettings:error:)], @"LocationHostApi api (%@) doesn't respond to @selector(changeNotificationSettingsSettings:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PigeonNotificationSettings *arg_settings = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api changeNotificationSettingsSettings:arg_settings error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.LocationHostApi.setBackgroundActivated"
        binaryMessenger:binaryMessenger
        codec:LocationHostApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBackgroundActivatedActivated:error:)], @"LocationHostApi api (%@) doesn't respond to @selector(setBackgroundActivatedActivated:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_activated = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api setBackgroundActivatedActivated:arg_activated error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
