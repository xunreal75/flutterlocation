// Autogenerated from Pigeon (v10.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

enum PigeonLocationAccuracy {
  powerSave,
  low,
  balanced,
  high,
  navigation,
}

class PigeonLocationData {
  PigeonLocationData({
    this.latitude,
    this.longitude,
    this.accuracy,
    this.altitude,
    this.bearing,
    this.bearingAccuracyDegrees,
    this.elaspedRealTimeNanos,
    this.elaspedRealTimeUncertaintyNanos,
    this.satellites,
    this.speed,
    this.speedAccuracy,
    this.time,
    this.verticalAccuracy,
    this.isMock,
  });

  double? latitude;

  double? longitude;

  double? accuracy;

  double? altitude;

  double? bearing;

  double? bearingAccuracyDegrees;

  double? elaspedRealTimeNanos;

  double? elaspedRealTimeUncertaintyNanos;

  int? satellites;

  double? speed;

  double? speedAccuracy;

  double? time;

  double? verticalAccuracy;

  bool? isMock;

  Object encode() {
    return <Object?>[
      latitude,
      longitude,
      accuracy,
      altitude,
      bearing,
      bearingAccuracyDegrees,
      elaspedRealTimeNanos,
      elaspedRealTimeUncertaintyNanos,
      satellites,
      speed,
      speedAccuracy,
      time,
      verticalAccuracy,
      isMock,
    ];
  }

  static PigeonLocationData decode(Object result) {
    result as List<Object?>;
    return PigeonLocationData(
      latitude: result[0] as double?,
      longitude: result[1] as double?,
      accuracy: result[2] as double?,
      altitude: result[3] as double?,
      bearing: result[4] as double?,
      bearingAccuracyDegrees: result[5] as double?,
      elaspedRealTimeNanos: result[6] as double?,
      elaspedRealTimeUncertaintyNanos: result[7] as double?,
      satellites: result[8] as int?,
      speed: result[9] as double?,
      speedAccuracy: result[10] as double?,
      time: result[11] as double?,
      verticalAccuracy: result[12] as double?,
      isMock: result[13] as bool?,
    );
  }
}

class PigeonNotificationSettings {
  PigeonNotificationSettings({
    this.channelName,
    this.title,
    this.iconName,
    this.subtitle,
    this.description,
    this.color,
    this.onTapBringToFront,
  });

  String? channelName;

  String? title;

  String? iconName;

  String? subtitle;

  String? description;

  String? color;

  bool? onTapBringToFront;

  Object encode() {
    return <Object?>[
      channelName,
      title,
      iconName,
      subtitle,
      description,
      color,
      onTapBringToFront,
    ];
  }

  static PigeonNotificationSettings decode(Object result) {
    result as List<Object?>;
    return PigeonNotificationSettings(
      channelName: result[0] as String?,
      title: result[1] as String?,
      iconName: result[2] as String?,
      subtitle: result[3] as String?,
      description: result[4] as String?,
      color: result[5] as String?,
      onTapBringToFront: result[6] as bool?,
    );
  }
}

class PigeonLocationSettings {
  PigeonLocationSettings({
    required this.askForPermission,
    required this.rationaleMessageForPermissionRequest,
    required this.rationaleMessageForGPSRequest,
    required this.useGooglePlayServices,
    required this.askForGooglePlayServices,
    required this.askForGPS,
    required this.fallbackToGPS,
    required this.ignoreLastKnownPosition,
    this.expirationDuration,
    this.expirationTime,
    required this.fastestInterval,
    required this.interval,
    this.maxWaitTime,
    this.numUpdates,
    required this.accuracy,
    required this.smallestDisplacement,
    required this.waitForAccurateLocation,
    this.acceptableAccuracy,
  });

  bool askForPermission;

  String rationaleMessageForPermissionRequest;

  String rationaleMessageForGPSRequest;

  bool useGooglePlayServices;

  bool askForGooglePlayServices;

  bool askForGPS;

  bool fallbackToGPS;

  bool ignoreLastKnownPosition;

  double? expirationDuration;

  double? expirationTime;

  double fastestInterval;

  double interval;

  double? maxWaitTime;

  int? numUpdates;

  PigeonLocationAccuracy accuracy;

  double smallestDisplacement;

  bool waitForAccurateLocation;

  double? acceptableAccuracy;

  Object encode() {
    return <Object?>[
      askForPermission,
      rationaleMessageForPermissionRequest,
      rationaleMessageForGPSRequest,
      useGooglePlayServices,
      askForGooglePlayServices,
      askForGPS,
      fallbackToGPS,
      ignoreLastKnownPosition,
      expirationDuration,
      expirationTime,
      fastestInterval,
      interval,
      maxWaitTime,
      numUpdates,
      accuracy.index,
      smallestDisplacement,
      waitForAccurateLocation,
      acceptableAccuracy,
    ];
  }

  static PigeonLocationSettings decode(Object result) {
    result as List<Object?>;
    return PigeonLocationSettings(
      askForPermission: result[0]! as bool,
      rationaleMessageForPermissionRequest: result[1]! as String,
      rationaleMessageForGPSRequest: result[2]! as String,
      useGooglePlayServices: result[3]! as bool,
      askForGooglePlayServices: result[4]! as bool,
      askForGPS: result[5]! as bool,
      fallbackToGPS: result[6]! as bool,
      ignoreLastKnownPosition: result[7]! as bool,
      expirationDuration: result[8] as double?,
      expirationTime: result[9] as double?,
      fastestInterval: result[10]! as double,
      interval: result[11]! as double,
      maxWaitTime: result[12] as double?,
      numUpdates: result[13] as int?,
      accuracy: PigeonLocationAccuracy.values[result[14]! as int],
      smallestDisplacement: result[15]! as double,
      waitForAccurateLocation: result[16]! as bool,
      acceptableAccuracy: result[17] as double?,
    );
  }
}

class _LocationHostApiCodec extends StandardMessageCodec {
  const _LocationHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PigeonLocationData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is PigeonLocationSettings) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PigeonLocationSettings) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PigeonNotificationSettings) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return PigeonLocationData.decode(readValue(buffer)!);
      case 129: 
        return PigeonLocationSettings.decode(readValue(buffer)!);
      case 130: 
        return PigeonLocationSettings.decode(readValue(buffer)!);
      case 131: 
        return PigeonNotificationSettings.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class LocationHostApi {
  /// Constructor for [LocationHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  LocationHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _LocationHostApiCodec();

  Future<PigeonLocationData> getLocation(PigeonLocationSettings? arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.getLocation', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as PigeonLocationData?)!;
    }
  }

  Future<bool> setLocationSettings(PigeonLocationSettings arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.setLocationSettings', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<int> getPermissionStatus() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.getPermissionStatus', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as int?)!;
    }
  }

  Future<int> requestPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.requestPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as int?)!;
    }
  }

  Future<bool> isGPSEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.isGPSEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> isNetworkEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.isNetworkEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> changeNotificationSettings(PigeonNotificationSettings arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.changeNotificationSettings', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> setBackgroundActivated(bool arg_activated) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.setBackgroundActivated', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_activated]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}
